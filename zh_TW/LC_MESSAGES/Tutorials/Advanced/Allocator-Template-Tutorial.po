# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation rolling\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-18 08:29+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:7
msgid "Implementing a custom memory allocator"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:9
msgid ""
"**Goal:** This tutorial will show how to use a custom memory allocator when "
"writing ROS 2 C++ code."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:11
msgid "**Tutorial level:** Advanced"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:13
msgid "**Time:** 20 minutes"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:17
msgid "Table of Contents"
msgstr "目次表"

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:19
msgid ""
"This tutorial will teach you how to integrate a custom allocator for "
"publishers and subscribers so that the default heap allocator is never "
"called while your ROS nodes are executing. The code for this tutorial is "
"available `here <https://github.com/ros2/demos/blob/rolling/demo_nodes_cpp/"
"src/topics/allocator_tutorial_pmr.cpp>`__."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:23
msgid "Background"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:25
msgid ""
"Suppose you want to write real-time safe code, and you've heard about the "
"many dangers of calling ``new`` during the real-time critical section, "
"because the default heap allocator on most platforms is nondeterministic."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:27
msgid ""
"By default, many C++ standard library structures will implicitly allocate "
"memory as they grow, such as ``std::vector``. However, these data structures "
"also accept an \"Allocator\" template argument. If you specify a custom "
"allocator to one of these data structures, it will use that allocator "
"instead of the system allocator to grow or shrink the data structure. Your "
"custom allocator could have a pool of memory preallocated on the stack, "
"which might be better suited to real-time applications."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:32
msgid ""
"In the ROS 2 C++ client library (rclcpp), we are following a similar "
"philosophy to the C++ standard library. Publishers, subscribers, and the "
"Executor accept an Allocator template parameter that controls allocations "
"made by that entity during execution."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:36
msgid "Writing an allocator"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:38
msgid ""
"To write an allocator compatible with ROS 2's allocator interface, your "
"allocator must be compatible with the C++ standard library allocator "
"interface."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:40
msgid ""
"Since C++17, the standard library provides something called ``std::pmr::"
"memory_resource``. This is a class that can be derived from to create a "
"custom allocator that fulfills a minimum set of requirements."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:43
msgid ""
"For example, the following declaration for a custom memory resource fulfills "
"the requirements (of course, you would still need to implement the declared "
"functions in this class):"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:45
msgid ""
"class CustomMemoryResource : public std::pmr::memory_resource\n"
"{\n"
"private:\n"
"  void * do_allocate(std::size_t bytes, std::size_t alignment) override;\n"
"\n"
"  void do_deallocate(\n"
"    void * p, std::size_t bytes,\n"
"    std::size_t alignment) override;\n"
"\n"
"  bool do_is_equal(\n"
"    const std::pmr::memory_resource & other) const noexcept override;\n"
"};"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:60
msgid ""
"To learn about the full capabilities of ``std::pmr::memory_resource``, see "
"https://en.cppreference.com/w/cpp/memory/memory_resource."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:62
msgid ""
"The full implementation of the custom allocator for this tutorial is in "
"https://github.com/ros2/demos/blob/rolling/demo_nodes_cpp/src/topics/"
"allocator_tutorial_pmr.cpp."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:65
msgid "Writing an example main"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:67
msgid ""
"Once you have written a valid C++ allocator, you must pass it as a shared "
"pointer to your publisher, subscriber, and executor. But first, we'll "
"declare a few aliases to shorten the names."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:70
msgid ""
"using rclcpp::memory_strategies::allocator_memory_strategy::"
"AllocatorMemoryStrategy;\n"
"using Alloc = std::pmr::polymorphic_allocator<void>;\n"
"using MessageAllocTraits =\n"
"  rclcpp::allocator::AllocRebind<std_msgs::msg::UInt32, Alloc>;\n"
"using MessageAlloc = MessageAllocTraits::allocator_type;\n"
"using MessageDeleter = rclcpp::allocator::Deleter<MessageAlloc, std_msgs::"
"msg::UInt32>;\n"
"using MessageUniquePtr = std::unique_ptr<std_msgs::msg::UInt32, "
"MessageDeleter>;"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:80
msgid "Now we can create our resources with the custom allocator:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:82
msgid ""
"CustomMemoryResource mem_resource{};\n"
"auto alloc = std::make_shared<Alloc>(&mem_resource);\n"
"rclcpp::PublisherOptionsWithAllocator<Alloc> publisher_options;\n"
"publisher_options.allocator = alloc;\n"
"auto publisher = node->create_publisher<std_msgs::msg::UInt32>(\n"
"  \"allocator_tutorial\", 10, publisher_options);\n"
"\n"
"rclcpp::SubscriptionOptionsWithAllocator<Alloc> subscription_options;\n"
"subscription_options.allocator = alloc;\n"
"auto msg_mem_strat = std::make_shared<\n"
"  rclcpp::message_memory_strategy::MessageMemoryStrategy<\n"
"    std_msgs::msg::UInt32, Alloc>>(alloc);\n"
"auto subscriber = node->create_subscription<std_msgs::msg::UInt32>(\n"
"  \"allocator_tutorial\", 10, callback, subscription_options, "
"msg_mem_strat);\n"
"\n"
"std::shared_ptr<rclcpp::memory_strategy::MemoryStrategy> memory_strategy =\n"
"  std::make_shared<AllocatorMemoryStrategy<Alloc>>(alloc);\n"
"\n"
"rclcpp::ExecutorOptions options;\n"
"options.memory_strategy = memory_strategy;\n"
"rclcpp::executors::SingleThreadedExecutor executor(options);"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:106
msgid ""
"You must also instantiate a custom deleter and allocator for use when "
"allocating messages:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:108
msgid ""
"MessageDeleter message_deleter;\n"
"MessageAlloc message_alloc = *alloc;\n"
"rclcpp::allocator::set_allocator_for_deleter(&message_deleter, "
"&message_alloc);"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:114
msgid ""
"Once you've add the node to the executor, it is time to spin. We'll use the "
"custom allocator to allocate each message:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:117
msgid ""
"uint32_t i = 0;\n"
"while (rclcpp::ok()) {\n"
"  auto ptr = MessageAllocTraits::allocate(message_alloc, 1);\n"
"  MessageAllocTraits::construct(message_alloc, ptr);\n"
"  MessageUniquePtr msg(ptr, message_deleter);\n"
"  msg->data = i;\n"
"  ++i;\n"
"  publisher->publish(std::move(msg));\n"
"  rclcpp::sleep_for(10ms);\n"
"  executor.spin_some();\n"
"}"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:132
msgid "Passing an allocator to the intra-process pipeline"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:134
msgid ""
"Even though we instantiated a publisher and subscriber in the same process, "
"we aren't using the intra-process pipeline yet."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:136
msgid ""
"The IntraProcessManager is a class that is usually hidden from the user, but "
"in order to pass a custom allocator to it we need to expose it by getting it "
"from the rclcpp Context. The IntraProcessManager makes use of several "
"standard library structures, so without a custom allocator it will call the "
"default ``new``."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:139
msgid ""
"auto context = rclcpp::contexts::get_global_default_context();\n"
"auto options = rclcpp::NodeOptions()\n"
"  .context(context)\n"
"  .use_intra_process_comms(true);\n"
"auto node = rclcpp::Node::make_shared(\"allocator_example\", options);"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:147
msgid ""
"Make sure to instantiate publishers and subscribers AFTER constructing the "
"node in this way."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:150
msgid "Testing and verifying the code"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:152
msgid "How do you know that your custom allocator is actually getting called?"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:154
msgid ""
"The obvious thing to do would be to count the calls made to your custom "
"allocator's ``allocate`` and ``deallocate`` functions and compare that to "
"the calls to ``new`` and ``delete``."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:156
msgid "Adding counting to the custom allocator is easy:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:158
msgid ""
"void * do_allocate(std::size_t size, std::size_t alignment) override\n"
"{\n"
"  // ...\n"
"  num_allocs++;\n"
"  // ...\n"
"}\n"
"\n"
"void do_deallocate(\n"
"  void * p, std::size_t bytes,\n"
"  std::size_t alignment) override\n"
"{\n"
"  // ...\n"
"  num_deallocs++;\n"
"  // ...\n"
"}"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:176
msgid "You can also override the global ``new`` and ``delete`` operators:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:178
msgid ""
"void * operator new(std::size_t size)\n"
"{\n"
"  if (is_running) {\n"
"    global_runtime_allocs++;\n"
"  }\n"
"  return std::malloc(size);\n"
"}\n"
"\n"
"void operator delete(void * ptr, size_t) noexcept\n"
"{\n"
"  if (ptr != nullptr) {\n"
"    if (is_running) {\n"
"      global_runtime_deallocs++;\n"
"    }\n"
"    std::free(ptr);\n"
"  }\n"
"}\n"
"\n"
"void operator delete(void * ptr) noexcept\n"
"{\n"
"  if (ptr != nullptr) {\n"
"    if (is_running) {\n"
"      global_runtime_deallocs++;\n"
"    }\n"
"    std::free(ptr);\n"
"  }\n"
"}"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:208
msgid ""
"where the variables we are incrementing are just global static integers, and "
"``is_running`` is a global static boolean that gets toggled right before the "
"call to ``spin``."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:210
msgid ""
"The `example executable <https://github.com/ros2/demos/blob/rolling/"
"demo_nodes_cpp/src/topics/allocator_tutorial_pmr.cpp>`__ prints the value of "
"the variables. To run the example executable, use:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:213
msgid "$ ros2 run demo_nodes_cpp allocator_tutorial"
msgstr "$ ros2 run demo_nodes_cpp allocator_tutorial"

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:217
msgid "or, to run the example with the intra-process pipeline on:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:219
msgid ""
"$ ros2 run demo_nodes_cpp allocator_tutorial intra\n"
"Global new was called 15590 times during spin\n"
"Global delete was called 15590 times during spin\n"
"Allocator new was called 27284 times during spin\n"
"Allocator delete was called 27281 times during spin"
msgstr ""
"$ ros2 run demo_nodes_cpp allocator_tutorial intra\n"
"Global new was called 15590 times during spin\n"
"Global delete was called 15590 times during spin\n"
"Allocator new was called 27284 times during spin\n"
"Allocator delete was called 27281 times during spin"

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:227
msgid ""
"We've caught about 2/3 of the allocations/deallocations that happen on the "
"execution path, but where do the remaining 1/3 come from?"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:229
msgid ""
"As a matter of fact, these allocations/deallocations originate in the "
"underlying DDS implementation used in this example."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:231
msgid ""
"Proving this is out of the scope of this tutorial, but you can check out the "
"test for the allocation path that gets run as part of the ROS 2 continuous "
"integration testing, which backtraces through the code and figures out "
"whether certain function calls originate in the rmw implementation or in a "
"DDS implementation:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:233
msgid ""
"https://github.com/ros2/realtime_support/blob/rolling/tlsf_cpp/test/"
"test_tlsf.cpp#L41"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:235
msgid ""
"Note that this test is not using the custom allocator we just created, but "
"the TLSF allocator (see below)."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:238
msgid "The TLSF allocator"
msgstr "TLSF 分配器"

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:240
msgid ""
"ROS 2 offers support for the TLSF (Two Level Segregate Fit) allocator, which "
"was designed to meet real-time requirements:"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:242
msgid "https://github.com/ros2/realtime_support/tree/rolling/tlsf_cpp"
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:244
msgid ""
"For more information about TLSF, see `this page via Universitat Politècnica "
"de València <http://www.gii.upv.es/tlsf/>`_."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:246
msgid "Note that the TLSF allocator is licensed under a dual-GPL/LGPL license."
msgstr ""

#: ../../../source/Tutorials/Advanced/Allocator-Template-Tutorial.rst:248
msgid ""
"A full working example using the TLSF allocator is here: https://github.com/"
"ros2/realtime_support/blob/rolling/tlsf_cpp/example/allocator_example.cpp"
msgstr ""
