# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2018, Open Robotics
# This file is distributed under the same license as the ros2 documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ros2 documentation crystal\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-08-13 06:54+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../source/Tutorials/Sync-Vs-Async.rst:4
msgid "Synchronous vs. asynchronous service clients"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:6
msgid "**Level:** Intermediate"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:8
msgid "**Time:** 10 minutes"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:13
msgid "Contents"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:16
msgid "Introduction"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:18
msgid ""
"This guide is intended to warn users of the risks associated with the Python "
"synchronous service client ``call()`` API. It is very easy to mistakenly "
"cause deadlock when calling services synchronously, so we do not recommend "
"using ``call()``."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:21
msgid ""
"We provide an example on how to use ``call()`` correctly for experienced "
"users who wish to use synchronous calls and are aware of the pitfalls. We "
"also highlight possible scenarios for deadlock that accompany it."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:24
msgid ""
"Because we recommend avoiding sync calls, this guide will also address the "
"features and usage of the recommended alternative, async calls "
"(``call_async()``)."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:26
msgid ""
"The C++ service call API is only available in async, so the comparisons and "
"examples in this guide pertain to Python services and clients. The "
"definition of async given here generally applies to C++, with some "
"exceptions."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:30
msgid "1 Synchronous calls"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:32
msgid ""
"A synchronous client will block the calling thread when sending a request to "
"a service until a response has been received; nothing else can happen on "
"that thread during the call. The call can take arbitrary amounts of time to "
"complete. Once complete, the response returns directly to the client."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:36
msgid ""
"The following is an example of how to correctly execute a synchronous client "
"node, similar to the async node in the :ref:`Simple Service and Client "
"<PySrvCli>` tutorial."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:38
msgid ""
"import sys\n"
"from threading import Thread\n"
"\n"
"from example_interfaces.srv import AddTwoInts\n"
"import rclpy\n"
"from rclpy.node import Node\n"
"\n"
"class MinimalClientSync(Node):\n"
"\n"
"    def __init__(self):\n"
"        super().__init__('minimal_client_sync')\n"
"        self.cli = self.create_client(AddTwoInts, 'add_two_ints')\n"
"        while not self.cli.wait_for_service(timeout_sec=1.0):\n"
"            self.get_logger().info('service not available, waiting "
"again...')\n"
"        self.req = AddTwoInts.Request()\n"
"\n"
"    def send_request(self):\n"
"        self.req.a = int(sys.argv[1])\n"
"        self.req.b = int(sys.argv[2])\n"
"        return self.cli.call(self.req)\n"
"        # This only works because rclpy.spin() is called in a separate "
"thread below.\n"
"        # Another configuration, like spinning later in main() or calling "
"this method from a timer callback, would result in a deadlock.\n"
"\n"
"def main():\n"
"    rclpy.init()\n"
"\n"
"    minimal_client = MinimalClientSync()\n"
"\n"
"    spin_thread = Thread(target=rclpy.spin, args=(minimal_client,))\n"
"    spin_thread.start()\n"
"\n"
"    response = minimal_client.send_request()\n"
"    minimal_client.get_logger().info(\n"
"        'Result of add_two_ints: for %d + %d = %d' %\n"
"        (minimal_client.req.a, minimal_client.req.b, response.sum))\n"
"\n"
"    minimal_client.destroy_node()\n"
"    rclpy.shutdown()\n"
"\n"
"\n"
"if __name__ == '__main__':\n"
"    main()"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:83
msgid ""
"Note inside ``main()`` that the client calls ``rclpy.spin`` in a separate "
"thread. Both ``send_request`` and ``rclpy.spin`` are blocking, so they need "
"to be on separate threads."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:87
msgid "1.1 Sync deadlock"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:89
msgid ""
"There are several ways that the synchronous ``call()`` API can cause "
"deadlock."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:91
msgid ""
"As mentioned in the comments of the example above, failing to create a "
"separate thread to spin ``rclpy`` is one cause of deadlock. When a client is "
"blocking a thread waiting for a response, but the response can only be "
"returned on that same thread, the client will never stop waiting, and "
"nothing else can happen."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:94
msgid ""
"Another cause of deadlock is blocking ``rclpy.spin`` by calling a service "
"synchronously in a subscription, timer callback or service callback. For "
"example, if the synchronous client's ``send_request`` is placed in a "
"callback:"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:97
msgid ""
"def trigger_request(msg):\n"
"    response = minimal_client.send_request()  # This will cause deadlock\n"
"    minimal_client.get_logger().info(\n"
"        'Result of add_two_ints: for %d + %d = %d' %\n"
"        (minimal_client.req.a, minimal_client.req.b, response.sum))\n"
"subscription = minimal_client.create_subscription(String, 'trigger', "
"trigger_request, 10)\n"
"\n"
"rclpy.spin(minimal_client)"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:108
msgid ""
"Deadlock occurs because ``rclpy.spin`` will not preempt the callback with "
"the ``send_request`` call. In general, callbacks should only perform light "
"and fast operations."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:113
msgid ""
"When deadlock occurs, you will not receive any indication that the service "
"is blocked. There will be no warning or exception thrown, no indication in "
"the stack trace, and the call will not fail."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:117
msgid "2 Asynchronous calls"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:119
msgid ""
"Async calls in ``rclpy`` are entirely safe and the recommended method of "
"calling services. They can be made from anywhere without running the risk of "
"blocking other ROS and non-ROS processes, unlike sync calls."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:122
msgid ""
"An asynchronous client will immediately return ``future``, a value that "
"indicates whether the call and response is finished (not the value of the "
"response itself), after sending a request to a service. The returned "
"``future`` may be queried for a response at any time."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:125
msgid ""
"Since sending a request doesnâ€™t block anything, a loop can be used to both "
"spin ``rclpy`` and check ``future`` in the same thread, for example:"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:127
msgid ""
"while rclpy.ok():\n"
"    rclpy.spin_once(node)\n"
"    if future.done():\n"
"        #Get response"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:134
msgid ""
"The :ref:`Simple Service and Client <PySrvCli>` tutorial for Python "
"illustrates how to perform an async service call and retrieve the ``future`` "
"using a loop."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:136
msgid ""
"The ``future`` can also be retrieved using a timer or callback, like in "
"`this example <https://github.com/ros2/examples/blob/dashing/rclpy/services/"
"minimal_client/examples_rclpy_minimal_client/client_async_callback.py>`_, a "
"dedicated thread, or by another method. It is up to you, as the caller, to "
"decide how to store ``future``, check on its status, and retrieve your "
"response."
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:140
msgid "Summary"
msgstr ""

#: ../../../source/Tutorials/Sync-Vs-Async.rst:142
msgid ""
"It is not recommended to implement a synchronous service client. They are "
"susceptible to deadlock, but will not provide any indication of issue when "
"deadlock occurs. If you must use synchronous calls, the example in section "
"`1 Synchronous calls`_ is a safe method of doing so. You should also be "
"aware of the conditions that cause deadlock outlined in section `1.1 Sync "
"deadlock`_. We recommend using async service clients instead."
msgstr ""
