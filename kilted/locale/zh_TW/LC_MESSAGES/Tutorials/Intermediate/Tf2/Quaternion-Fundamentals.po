# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2025, Open Robotics
# This file is distributed under the same license as the ROS 2 documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: ROS 2 documentation kilted\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-09-01 08:36+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:8
msgid "Quaternion fundamentals"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:10
msgid "**Goal:** Learn the basics of quaternion usage in ROS 2."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:12
msgid "**Tutorial level:** Intermediate"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:14
msgid "**Time:** 10 minutes"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:18
msgid "Contents"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:21
msgid "Background"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:23
msgid ""
"A quaternion is a 4-tuple representation of orientation, which is more "
"concise than a rotation matrix. Quaternions are very efficient for analyzing "
"situations where rotations in three dimensions are involved. Quaternions are "
"used widely in robotics, quantum mechanics, computer vision, and 3D "
"animation."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:27
msgid ""
"You can learn more about the underlying mathematical concept on `Wikipedia "
"<https://en.wikipedia.org/wiki/Quaternion>`_. You can also take a look at an "
"explorable video series `Visualizing quaternions <https://eater.net/"
"quaternions>`_ made by `3blue1brown <https://www.youtube.com/3blue1brown>`_."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:30
msgid ""
"In this tutorial, you will learn how quaternions and conversion methods work "
"in ROS 2."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:33
msgid "Prerequisites"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:35
msgid ""
"You can take a look at libraries like `transforms3d <https://github.com/"
"matthew-brett/transforms3d>`_, `scipy.spatial.transform <https://github.com/"
"scipy/scipy/tree/master/scipy/spatial/transform>`_, `pytransform3d <https://"
"github.com/rock-learning/pytransform3d>`_, `numpy-quaternion <https://github."
"com/moble/quaternion>`_ or `blender.mathutils <https://docs.blender.org/api/"
"master/mathutils.html>`_."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:37
msgid ""
"However, this is not a hard requirement and you can stick to any other "
"geometric transformation library that suit you best."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:40
msgid "Components of a quaternion"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:42
msgid ""
"ROS 2 uses quaternions to track and apply rotations. A quaternion has 4 "
"components ``(x, y, z, w)``. In ROS 2, ``w`` is last, but in some libraries "
"like Eigen, ``w`` can be placed at the first position. The commonly-used "
"unit quaternion that yields no rotation about the x/y/z axes is ``(0, 0, 0, "
"1)``, and can be created in a following way:"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:47
msgid ""
"#include <tf2/LinearMath/Quaternion.hpp>\n"
"...\n"
"\n"
"tf2::Quaternion q;\n"
"// Create a quaternion from roll/pitch/yaw in radians (0, 0, 0)\n"
"q.setRPY(0, 0, 0);\n"
"// Print the quaternion components (0, 0, 0, 1)\n"
"RCLCPP_INFO(this->get_logger(), \"%f %f %f %f\",\n"
"            q.x(), q.y(), q.z(), q.w());"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:59
msgid ""
"The magnitude of a quaternion should always be one. If numerical errors "
"cause a quaternion magnitude other than one, ROS 2 will print warnings. To "
"avoid these warnings, normalize the quaternion:"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:63
msgid "q.normalize();"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:68
msgid "Quaternion types in ROS 2"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:70
msgid ""
"ROS 2 uses two quaternion datatypes: ``tf2::Quaternion`` and its equivalent "
"``geometry_msgs::msg::Quaternion``. To convert between them in C++, use the "
"methods of ``tf2_geometry_msgs``."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:73
msgid ""
"#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>\n"
"...\n"
"\n"
"tf2::Quaternion tf2_quat, tf2_quat_from_msg;\n"
"tf2_quat.setRPY(roll, pitch, yaw);\n"
"// Convert tf2::Quaternion to geometry_msgs::msg::Quaternion\n"
"geometry_msgs::msg::Quaternion msg_quat = tf2::toMsg(tf2_quat);\n"
"\n"
"// Convert geometry_msgs::msg::Quaternion to tf2::Quaternion\n"
"tf2::convert(msg_quat, tf2_quat_from_msg);\n"
"// or\n"
"tf2::fromMsg(msg_quat, tf2_quat_from_msg);"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:88
msgid ""
"There is no ``tf2::Quaternion`` equivalent in Python. Instead, the builtin "
"``list`` is used."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:91
msgid ""
"from geometry_msgs.msg import Quaternion\n"
"...\n"
"\n"
"# Create a list of floats, which is compatible with tf2\n"
"# Quaternion methods\n"
"quat_tf = [0.0, 1.0, 0.0, 0.0]\n"
"\n"
"# Convert a list to geometry_msgs.msg.Quaternion\n"
"msg_quat = Quaternion(x=quat_tf[0], y=quat_tf[1], z=quat_tf[2], w=quat_tf[3])"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:104
msgid "Quaternion operations"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:107
msgid "1 Think in RPY then convert to quaternion"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:109
msgid ""
"It's easy for us to think of rotations about axes, but hard to think in "
"terms of quaternions. A suggestion is to calculate target rotations in terms "
"of the three individual rotations *roll* (about an X-axis), *pitch* (about "
"the Y-axis), and *yaw* (about the Z-axis), and then convert to a quaternion."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:112
msgid ""
"# quaternion_from_euler method is available in turtle_tf2_py/turtle_tf2_py/"
"turtle_tf2_broadcaster.py\n"
"q = quaternion_from_euler(1.5707, 0, -1.5707)\n"
"print(f'The quaternion representation is x: {q[0]} y: {q[1]} z: {q[2]} w: "
"{q[3]}.')"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:118
msgid ""
"This method relates to `Euler angles <https://en.wikipedia.org/wiki/"
"Euler_angles>`_. There are several ways of applying Euler angles. The one "
"described above, which ROS 2 adopts, is called *fixed (or static) frame* "
"RPY. This means that the three individual rotations are applied to the "
"original, unmoving coordinate axes. This is contrary to *relative frame*, "
"where rotations are applied to the coordinate axes that get transformed by "
"preceding rotations."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:126
msgid "2 Applying a quaternion rotation"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:128
msgid ""
"To apply the rotation of one quaternion to a pose, simply multiply the "
"previous quaternion of the pose by the quaternion representing the desired "
"rotation. The order of this multiplication matters."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:131
msgid "C++"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:133
msgid ""
"#include <tf2_geometry_msgs/tf2_geometry_msgs.hpp>\n"
"...\n"
"\n"
"tf2::Quaternion q_orig, q_rot, q_new;\n"
"\n"
"q_orig.setRPY(0.0, 0.0, 0.0);\n"
"// Rotate the previous pose by 180* about X\n"
"q_rot.setRPY(3.14159, 0.0, 0.0);\n"
"q_new = q_rot * q_orig;\n"
"q_new.normalize();"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:146
msgid "Python"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:148
msgid ""
"q_orig = quaternion_from_euler(0, 0, 0)\n"
"# Rotate the previous pose by 180* about X\n"
"q_rot = quaternion_from_euler(3.14159, 0, 0)\n"
"q_new = quaternion_multiply(q_rot, q_orig)"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:157
msgid "3 Inverting a quaternion"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:159
msgid "An easy way to invert a quaternion is to negate the w-component:"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:161
msgid "q[3] = -q[3]"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:167
msgid ""
"This should not be confused with negating *all* elements of the quaternion."
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:170
msgid "4 Relative rotations"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:172
msgid ""
"Say you have two quaternions from the same frame, ``q_1`` and ``q_2``. You "
"want to find the relative rotation, ``q_r``, that converts ``q_1`` to "
"``q_2`` in a following manner:"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:175
msgid "q_2 = q_r * q_1"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:179
msgid ""
"You can solve for ``q_r`` similarly to solving a matrix equation. Invert "
"``q_1`` and right-multiply both sides. Again, the order of multiplication is "
"important:"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:183
msgid "q_r = q_2 * q_1_inverse"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:187
msgid ""
"Here's an example to get the relative rotation from the previous robot pose "
"to the current robot pose in python:"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:189
msgid ""
"def quaternion_multiply(q0, q1):\n"
"    \"\"\"\n"
"    Multiplies two quaternions.\n"
"\n"
"    Input\n"
"    :param q0: A 4 element array containing the first quaternion (q01, q11, "
"q21, q31)\n"
"    :param q1: A 4 element array containing the second quaternion (q02, q12, "
"q22, q32)\n"
"\n"
"    Output\n"
"    :return: A 4 element array containing the final quaternion (q03,q13,q23,"
"q33)\n"
"\n"
"    \"\"\"\n"
"    # Extract the values from q0\n"
"    w0 = q0[0]\n"
"    x0 = q0[1]\n"
"    y0 = q0[2]\n"
"    z0 = q0[3]\n"
"\n"
"    # Extract the values from q1\n"
"    w1 = q1[0]\n"
"    x1 = q1[1]\n"
"    y1 = q1[2]\n"
"    z1 = q1[3]\n"
"\n"
"    # Compute the product of the two quaternions, term by term\n"
"    q0q1_w = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1\n"
"    q0q1_x = w0 * x1 + x0 * w1 + y0 * z1 - z0 * y1\n"
"    q0q1_y = w0 * y1 - x0 * z1 + y0 * w1 + z0 * x1\n"
"    q0q1_z = w0 * z1 + x0 * y1 - y0 * x1 + z0 * w1\n"
"\n"
"    # Create a 4 element array containing the final quaternion\n"
"    final_quaternion = np.array([q0q1_w, q0q1_x, q0q1_y, q0q1_z])\n"
"\n"
"    # Return a 4 element array containing the final quaternion (q02,q12,q22,"
"q32)\n"
"    return final_quaternion\n"
"\n"
"q1_inv[0] = prev_pose.pose.orientation.x\n"
"q1_inv[1] = prev_pose.pose.orientation.y\n"
"q1_inv[2] = prev_pose.pose.orientation.z\n"
"q1_inv[3] = -prev_pose.pose.orientation.w # Negate for inverse\n"
"\n"
"q2[0] = current_pose.pose.orientation.x\n"
"q2[1] = current_pose.pose.orientation.y\n"
"q2[2] = current_pose.pose.orientation.z\n"
"q2[3] = current_pose.pose.orientation.w\n"
"\n"
"qr = quaternion_multiply(q2, q1_inv)"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:240
msgid "Summary"
msgstr ""

#: ../../../source/Tutorials/Intermediate/Tf2/Quaternion-Fundamentals.rst:242
msgid ""
"In this tutorial, you learned about the fundamental concepts of a quaternion "
"and its related mathematical operations, like inversion and rotation. You "
"also learned about its usage examples in ROS 2 and conversion methods "
"between two separate Quaternion classes."
msgstr ""
